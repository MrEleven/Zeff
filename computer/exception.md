终于到异常这一节了。看了异常部分的开头，觉得ECF(异常控制流)真的好牛逼，进程，IO，虚拟内存，并发什么的都是基于ECF来实现的。

事件：状态变化成为事件。

操作系统在启动的时候会在内核区维护一张异常表。这样异常表的每一个条目k都包含了异常k的处理程序地址。当异常发生的时候，系统能根据异常表找到相应的处理程序，然后执行处理程序。

异常分四种：
* 中断：处理器外部的IO设备信号引起的异常叫中断。中断是异步发生的。说中断是异步的，我是这么理解的，计算机本身不会主动发起一个中断，它的产生依赖于外部条件，只有当IO读写状态变化了，这样才会触发事件，产生中断，这都是不是主动的。
* 陷阱：陷阱这个东西就比较牛逼了，系统调用就是陷阱。系统调用是什么我就不用多说了，用户态的进程可以通过系统调用访问内核中的信息。
* 故障：故障就是说发生了一些错误情况。故障有些是可以恢复的，比如：内存缺页。如果故障可以恢复，那么处理程序执行过后一般将故障的指令重新执行一遍，如果无法恢复，那么就会引起进程终止。
* 终止：不可恢复的致命错误，通常是硬件错误。

每个系统调用都有一个唯一的整数号，对应内核异常跳转表的偏移量。

还有一个有意思的东西就是，所有的到Linux系统调用的参数都是通过通用寄存器而不是栈传递的。因为系统调用的代码都是在内核中存在的，用户进程运行在用户态，跟内核的处理程序根本不在一个栈中。

书本上还举了一个很由意思的例子。用系统级函数write来写hello world程序。

吃饭很浪费事件，一般开始吃饭的时候都会打开一个视频看一会，然后就一直接着看。看书的心情都没有了。

睡了，睡了，晚安。