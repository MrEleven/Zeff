终于到异常这一节了。看了异常部分的开头，觉得ECF(异常控制流)真的好牛逼，进程，IO，虚拟内存，并发什么的都是基于ECF来实现的。

事件：状态变化成为事件。

操作系统在启动的时候会在内核区维护一张异常表。这样异常表的每一个条目k都包含了异常k的处理程序地址。当异常发生的时候，系统能根据异常表找到相应的处理程序，然后执行处理程序。

异常分四种：
* 中断：处理器外部的IO设备信号引起的异常叫中断。中断是异步发生的。说中断是异步的，我是这么理解的，计算机本身不会主动发起一个中断，它的产生依赖于外部条件，只有当IO读写状态变化了，这样才会触发事件，产生中断，这都是不是主动的。
* 陷阱：陷阱这个东西就比较牛逼了，系统调用就是陷阱。系统调用是什么我就不用多说了，用户态的进程可以通过系统调用访问内核中的信息。
* 故障：故障就是说发生了一些错误情况。故障有些是可以恢复的，比如：内存缺页。如果故障可以恢复，那么处理程序执行过后一般将故障的指令重新执行一遍，如果无法恢复，那么就会引起进程终止。
* 终止：不可恢复的致命错误，通常是硬件错误。

每个系统调用都有一个唯一的整数号，对应内核异常跳转表的偏移量。

还有一个有意思的东西就是，所有的到Linux系统调用的参数都是通过通用寄存器而不是栈传递的。因为系统调用的代码都是在内核中存在的，用户进程运行在用户态，跟内核的处理程序根本不在一个栈中。

书本上还举了一个很由意思的例子。用系统级函数write来写hello world程序。

吃饭很浪费事件，一般开始吃饭的时候都会打开一个视频看一会，然后就一直接着看。看书的心情都没有了。

睡了，睡了，晚安。

今天看了一下进程的东西。都是一些老生常谈的东西了，收获不是很大。sleep可以显示请求操作系统调度当前进程。getpid, getppid, fork, exit, waitpid, wait, sleep这几个函数和系统调用也是比较熟悉了。所以感觉收获不是很大。

不过今天又看了一篇mock的文章，感觉收获还是挺大的。如果掌握了mock这个新技能，估计又可以提升一个等级了。经验值累积到一定量的时候就可以进化啦。

今天家里断网，郁闷死，就到咖啡厅去看书。今天算是把异常部分结了，今天还按照书本上的例子，实现了一个简单的shell。

还发现一件又意思的事情，main函数的参数分别是argc, argv, envp。argc表示参数个数，argv是参数列表，envp是环境变量列表。argv, envp的结尾都是NULL，书本上有个例子是通过argv[argc] = NULL来判断参数的个数。于是我就产生了疑问，既然能够通过argv来判断argv的个数，为什么还要参数argc呢。

于是我就google了一下，然后在知乎上也提问了一下，有各种答案，有人说为了兼容老代码。有人说为了空间换时间，有人说就是冗余的。最好的回答感觉是哪个C99标准的文档，虽然我没看过，但是大概意思就是冗余的。但是argc才是判断标准，冗余的是argv[argc] = NULL。估计argv[argc] = NULL是有其他用途吧，根本不是用来确定参数个数的。

信号那部分也是蛮不错的，可以中断正常的执行流，中间插入信号处理程序，信号甚至可以抢占系统调用的执行权限，还可以屏蔽信号，老牛逼了。不过同一种类型的信号最多只能一个再等待处理，如果这种类型的信号已经有一个在等待了，后面发出的信号就会被简单丢弃。signal和alarm和kill方法好像很有用哦。关于竞争就在并发的时候再去仔细研究吧。

在咖啡厅看书还是很不错的，虽然看的页数很少，最起码不会被其他事情占用时间。其实我想建立一个组织，定期开我们自己的分享会，因为外面的分享会感觉层次太高了，不太适合我们。不过芝麻就要去北京了，本来还想听听芝麻关于docker和计算机网络的分享的呢，而我也更有兴趣去学Linux内核，有一句很有意思的话，当你不能让一个六岁的小孩理解一个东西的时候，你肯定没有真正理解它。所以让别人理解才是检验你真的懂这个东西。
