今天看了一下《深入理解计算机系统》的第七章链接部分。基本的内容其实之前就知道，收获不是很大。编译原理中涉及了这部分内容，Linux内核也涉及了这部分内容，Python源码也涉及了这部分内容。

我们拿到一个C源文件，首先GCC会预处理源文件，生成一个ascii码的中间文件。然后C编译器将 ascii文件翻译成一个汇编文件，然后汇编器将汇编文件翻译成一个可重定位目标文件，链接器将多个可重定位目标文件组合成可执行目标文件。

链接器主要完成两个任务，符号解析和重定位。符号解析就是将符号引用和符号定义关联起来。然后重定位将每个符号定义和一个存储器位置联系起来。

目标文件有三种形式：
* 可重定位目标文件。在编译时与其他可重定为目标文件合并，创建一个可执行目标文件。
* 可执行目标文件。可以直接拷贝到存储器执行的文件。
* 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态加载到存储器并链接。

还有就是ELF文件格式。ELF文件格式跟 Python中的pyc文件有点类似，不过比pyc复杂很多。 ELF格式主要分一下几个节。

* .text: 已经编译的程序的机器代码。
* .rodata：只读数据。
* .data：已初始化的全局C变量。
* .bss：未初始化的全局C变量。
* .symtab：符号表，存放程序中定义和引用的函数和全局变量的信息。
* .rel.text：引用外部代码的地址。
* .rel.data：引用外部数据的地址。
* .debug：调试符号表（不知道干嘛用的）
* .line：行号
* strtab: 字符串表。.symtab和.debug节中的符号表，以及节头部中的节名字。

现在大概知道每个节具体是干嘛用的，rel部分的都要是给链接器用的。
.bss一般存放那些只申明，而没有初始化的变量，链接的时候会把这些变量的地址从其他模块中获取过来的。符号表只存放一些符号，而.data和.bss存放的才是符号对应的变量的值。

这里还介绍了一个C语言的小技巧。用static将全局变量隐藏在模块的作用域中。

符号解析部分内容不多，主要是三条解析多重定义的全局符号的原则。多个强符号，一个强符号，多个弱符号的处理方法。

另外比较有意思的符号解析中的一个例子，两个模块中同时定义了x，但是一个是int，一个是double，结果double把x(int)后面的y也覆盖了，这种错误真的很难让程序员发现，貌似也没有说GCC有什么命令可以避免这种错误。下次可以拿这种错误去小朋友面前吹牛。哈哈

静态链接中引入了一个新概念，存档。存档比较牛逼，可以合并多个可重定为目标文件。静态就是把所有的用到的模块全部链接到可执行目标文件里来。不过有个悲剧的事情就是在你敲GCC链接命令的时候，后面的模块顺序会影响符号解析。不过这个问题可以用文档来解决。

重定位就是符号解析完成之后，所有的符号信息，引用和定义全部关联起来了，然后重定位就是把这些信息转化成存储器的位置，方便执行。

重定位是通过重定位条目这种数据结构来做的，一般有两种：重定位PC相对地址的引用，绝对地址引用。

可执行目标文件的ELF格式少了rel的两个节(因为都已经链接好了，就没用了)，这个格式也是为了运行时进程的内存结构设计的。

说的程序的执行就不得不说加载器，这就说到内核的东西了。主要是通过execve这个系统调用来实现的。这个系统调用会识别ELF格式，然后创建进程，进行一些初始化工作，最后调用ELF文件代码节中的main方法。

动态链接共享库就是执行的时候动态去调用一些公共的库。这本书上说得不是很清楚，不过看内核时候我看到过，主要是通过虚拟内存映射的机制实现的。这些公共库是所有进程共享的，说到共享就又说到之前看的mmap，进程内存结构中mmap就是专门负责这些事情的。不过明天还是要仔细看看动态链接这一节，感觉这本书这一节应该不会写的不好。

位置无关代码(PIC)
说实在话没看懂。只知道一个叫做GOT全局偏移量表解决了这个问题。明天继续看这个。



本来今天是要做缓存部分的家庭作业的，可是不太想做，总感觉没必要学得这么仔细。异常部分60页。感觉又可以看一个星期了。如果把异常机制弄明白了，感觉理解又会提升一个等级。还有就是经常觉得看这写东西，看着好像都懂，但是又不懂，每次回头重新看，有新得体会，但是总感觉没什么收获。让人郁闷啊。

PS：感觉跟端端他们的差距越来越大了。总觉得自己是井底之蛙，可是又不知道有什么办法可以让自己开开眼界，告诉自己该学写什么东西。加油


今天回顾了一下，大概知道PIC是怎么工作的了。数据段总是紧跟在代码段的后面，于是在数据段的头部建了一张GOT表，标识每个变量的偏移量，只要知道代码段的位置，那么变量的绝对地址就可以通过GOT推算出来。不过这样的开销相对来说会大一些。